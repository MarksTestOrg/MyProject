'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTestEvidence = undefined;

var _Config = require('./Config');

var _Config2 = _interopRequireDefault(_Config);

var _bitriseApi = require('../CLI/bitriseApi');

var _teamcityApi = require('../CLI/teamcityApi');

var _buddybuildApi = require('../CLI/buddybuildApi');

var _jenkinsApi = require('../CLI/jenkinsApi');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const config = new _Config2.default();
const testEvidenceJobs = config.testEvidenceJobs;

const createTestEvidenceString = testEvidence => {
  let textEvidenceString = '';
  testEvidence.forEach(section => {
    section.forEach(build => {
      textEvidenceString += `- ${build.jobName}: ${build.status} [Job Url](${build.url})`;
    });
  });
  if (textEvidenceString === '') {
    textEvidenceString = 'No test evidence available';
  }
  return textEvidenceString;
};

const getTestEvidence = exports.getTestEvidence = async () => {
  const testEvidence = await Promise.all(testEvidenceJobs.map(section => {
    const promises = [];
    section.builds.forEach(buildName => {
      switch (section.ciTool) {
        case 'bitrise':
          promises.push((0, _bitriseApi.findBitriseBuildTestEvidence)(buildName));
          break;
        case 'teamcity':
          promises.push((0, _teamcityApi.findTeamcityBuildTestEvidence)(buildName));
          break;
        case 'buddybuild':
          promises.push((0, _buddybuildApi.findBuddybuildBuildTestEvidence)(buildName));
          break;
        case 'jenkins':
          promises.push((0, _jenkinsApi.findJenkinsBuildTestEvidence)(buildName));
          break;
      }
    });
    return Promise.all(promises);
  }));
  return { testEvidence: createTestEvidenceString(testEvidence) };
};